fill = 'gray',
alpha = 0.01)+
ggplot2::geom_point()+
ggplot2::theme_light()+
ggplot2::ggtitle(paste0(site, " overnight variance values for radiation data products"), subtitle = "Gray boxes indicate test periods")+
ggplot2::xlab("Date")+
ggplot2::geom_smooth()
# EDIT
test <- "Air Temperature Data Quality"
testSubDir <- "TisAirTempDataQuality"
if(grepl("darwin", version$os))
{
dirCommBase<-"/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/"
}else{
dirCommBase<-"N:/Science/Science Commissioning Archive/SiteAndPayload/"
}
testFullDir=paste0(dirCommBase, testSubDir, "/")
bgn.month="2018-04"
end.month="2018-05"
test.sites=c("HARV", "JERC", "TREE", "KONZ", "KONA", "CPER", "JORN", "BARR", "HEAL")
#
# pq.results=read.csv(file = paste0(dirCommBase, "TisAirTempProcessQuality", "/Common/summary_results.csv"))
# pq.pass=pq.results[as.logical(pq.results$passed),]
# monthify=function(x){if(nchar(x)>7){substr(x, start = 1, stop = 7)}}
results=read.csv("/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/TisAirTempProcessQuality/Common/results.csv")
by.site=lapply(test.sites, function(x) unique(results[results$site==x,]))
testable=lapply(by.site, function(x) x[which.max(x$data_quantity[x$variable_tested=="tempSingle"]),])
testable=do.call(rbind, testable)
lapply(
testable$site, function(x) try(
Noble::air.temp.dq.test(
site=x,
bgn.month = testable$begin_month[testable$site==x],
end.month = testable$end_month[testable$site==x],
save.dir = testFullDir
)
)
)
dq.results=read.csv(file=Noble:::.result.route(testFullDir), stringsAsFactors = F)
parsed.results=do.call(rbind, lapply(test.sites, function(s) dq.results[dq.results$Site==s,][nrow(dq.results[dq.results$Site==s,]),]))
#parsed.results=Noble::parse.results(test.dir = testFullDir, write.summary = T)
library(Noble)
list.files(path="/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/TisAirTempDataQuality/", recursive = T)
uscrn_bad=list.files(path="/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/TisAirTempDataQuality/", recursive = T, full.names = T, pattern = "USCRN_")
uscrn_bad
uscrn_bad=list.files(path="/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/TisAirTempDataQuality/", recursive = T, full.names = T, pattern = "USCRN.")
uscrn_bad
file.remove(uscrn_bad)
double_dot=list.files(path="/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/TisAirTempDataQuality/", recursive = T, full.names = T, pattern = "..")
double_dot
double_dot=list.files(path="/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/TisAirTempDataQuality/", recursive = T, full.names = T, pattern = "\\.\\.")
double_dot
file.remove(double_dot)
list.files(path="/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/TisPrecipitationProcessQuality/", pattern = "exclude.csv", recursive = T, )
data=Noble::data.pull(site="STER", dpID = "DP1.00002.001", bgn.month = "2018-05", end.month = "2018-06", time.agr = 30, package = "basic", save.dir = tempdir())
time.agr=30
return<-"index"
valid.returns <- c("index", "times")
if(missing(return)){
message("No return type specified, will return an index of rows with missing data")
return<-"index"
}
if(!return %in% valid.returns){
stop("Please specify either 'index' or 'times' for the return parameter")
}
#make indicies for columns of time, data, and quality flags
time.indx <- grep(colnames(data), pattern = "time", ignore.case = T)
data.indx <- grep(x=colnames(data), pattern = "data|mean", ignore.case = T)
qf.indx <- grep(colnames(data), pattern = "qf", ignore.case = T)
# Convert the first timestamp sequence found to POSIX
data[, time.indx[1]]<-as.POSIXct(data[,time.indx[1]], format="%Y-%m-%d %H:%M:%S", tz="UTC")
# If the time.agr parameter isn't specified, make a guess about the value
if(missing(time.agr)){
time.agr<-as.numeric(difftime(data[2,time.indx[1]], data[1,time.indx[1]], units = "mins"))
message(paste0("No time.agr value specified, making an educated guess that it is: ", time.agr, " minutes."))
}
# Make a list of reference times, to check against
frst.time<-as.POSIXct(data[1,time.indx[1]], tz="UTC")
last.time<-as.POSIXct(data[length(data[,time.indx[1]]),time.indx[1]], tz="UTC")
num.times <- as.numeric(difftime(time1 = last.time, time2 = frst.time, units = "mins"))/time.agr+1
#Make a data frame with reference times
ref.times.df<- data.frame( "index"= seq.int(from = 1, to = num.times), "ref.times"=seq.POSIXt(from=frst.time, to=last.time, by=time.agr*60))
# Compare timestamps to posix sequence, Find indicies of POS.seq that are not in the data timestamps
miss.indx <- ref.times.df$index[which(!as.POSIXct(ref.times.df$ref.times) %in% as.POSIXct(data[,time.indx[1]]))] #Missing times
no.data.indx<- which(unlist(lapply(seq(from=1,to=length(data[,1]), by = 1), function(x) all(is.na(data[x,data.indx])))))
no.qf.indx <- which(unlist(lapply(seq(from=1,to=length(data[,1]), by = 1), function(x) all(is.na(data[x,qf.indx]))))) #missing all data
# Report the timestamps for missing data
miss.times <- ref.times.df$ref.times[miss.indx]
no.data.times <- data[no.data.indx,time.indx[1]] #[which(ref.times.df$index %in% na.time.indx)] #data[which(is.na(data[,data.indx])&data[,qf.indx]=="1"), time.indx[1]]
no.qf.times <- data[no.qf.indx,time.indx[1]]
#put everything into (named) lists
gap.index<-list(miss.times, no.data.indx, no.qf.indx)
names(gap.index)<-c("miss.times", "no.data.indx", "no.qf.indx")
gap.times<-list(miss.times, no.data.times, no.qf.times)
names(gap.times)<-c("miss.times", "no.data.times", "no.qf.times")
gap.index
gap.times
dpID="DP1.00002.001"
short.name=Noble::tis_pri_vars$short.name[Noble::tis_pri_vars$dpID==dpID]
raw.mls=zoo::na.trim(stringr::str_extract(string = colnames(data), pattern = "\\.\\d\\d\\d\\.\\d\\d\\d"))
tower.mls=as.numeric(unique(stringr::str_sub(raw.mls, start = 7, end = 7)))
locs=as.character(na.exclude(unique(stringr::str_extract(string = colnames(data), pattern = "\\d{3}\\.\\d{3}"))))
sp.locs=unique(substr(x=locs, start = 3,3))
sp.locs=sp.locs[!sp.locs==0]
ml.locs=unique(substr(x=locs, start=6,6))
ml.locs=ml.locs[!ml.locs==0]
all.locs=list(ml.locs=ml.locs, sp.locs=sp.locs)
## Below function from answer provided by Joris Meys, on stackoverflow.com.
## Retrieved Dec 20, 2017 from https://stackoverflow.com/questions/7077710/sequence-length-encoding-using-r?rq=1
seq.length <- function(x){
if(!is.numeric(x)) x <- as.numeric(x)
n <- length(x)
y <- x[-1L] != x[-n] + 1L
i <- c(which(y|is.na(y)),n)
data.frame(
start_index = as.vector(x[head(c(0L,i)+1L,-1L)]),
stop_index = as.vector(diff(c(0L,i)))
)
}
soil.DPs=c("DP1.00040.001", "DP1.00041.001", "DP1.00095.001")
data.time.table=function(l, loc){
l=as.character(l)
if(loc=="sp"){
l.data=Noble::sp.extract(data=data, sp = l)
}else if(loc=="ml"){
l.data=Noble::ml.extract(data=data, ml = l)
}
gaps=Noble::find.gap(data = l.data, time.agr = 30, return = "index")
no.data.times=seq.length(gaps$no.data.indx)
no.data.times$stop_index=(no.data.times$start_index+no.data.times$stop_index-1)
location=paste0(toupper(loc),"-", l)
no.data.times=data.frame(location=rep(location, times=nrow(no.data.times)),gap.start=l.data$startDateTime[no.data.times$start_index], gap.end=l.data$startDateTime[no.data.times$stop_index])
}
qf.time.table=function(l, loc){
if(loc=="sp"){
l.data=Noble::sp.extract(data=data, sp = l)
}else if(loc=="ml"){
l.data=Noble::ml.extract(data=data, ml = l)
}
gaps=Noble::find.gap(data = l.data, time.agr = 30, return = "index")
no.qf.times=seq.length(gaps$no.qf.indx)
no.qf.times$stop_index=(no.qf.times$start_index+no.qf.times$stop_index-1)
location=paste0(toupper(loc),"-", l)
no.qf.times=data.frame(location=rep(location, times=nrow(no.qf.times)),gap.start=l.data$startDateTime[no.qf.times$start_index], gap.end=l.data$startDateTime[no.qf.times$stop_index])
}
sp.no.data=lapply(all.locs$sp.locs, function(l) data.time.table(l, loc="sp"))
sp.no.qf=lapply(all.locs$sp.locs, function(l) qf.time.table(l, loc="sp"))
ml.no.data=lapply(all.locs$ml.locs, function(l) data.time.table(l, loc="ml"))
ml.no.qf=lapply(all.locs$ml.locs, function(l) qf.time.table(l, loc="ml"))
no.data.times=rbind(do.call(rbind, sp.no.data), do.call(rbind, ml.no.data))
no.qf.times=rbind(do.call(rbind, sp.no.qf), do.call(rbind, ml.no.qf))
no.data.times=no.data.times[-which(no.data.times[,2]==no.data.times[,3]),] #weed out weird duplicates
write.csv(x = no.data.times, file = paste0(save.dir, "/", site, "_", bgn.month, "-", end.month, "_", short.name, "_NO_DATA.csv"),row.names = F)
write.csv(x = no.qf.times, file = paste0(save.dir, "/", site, "_", bgn.month, "-", end.month,  "_", short.name, "_NO_QF.csv"))
site="STER"
bgn.month="2018-05"
end.month="2018-06"
data=Noble::data.pull(dpID = dpID, site = site, bgn.month = bgn.month, end.month = end.month,
time.agr = 30, package = "basic", save.dir = tempdir())
short.name=Noble::tis_pri_vars$short.name[Noble::tis_pri_vars$dpID==dpID]
raw.mls=zoo::na.trim(stringr::str_extract(string = colnames(data), pattern = "\\.\\d\\d\\d\\.\\d\\d\\d"))
tower.mls=as.numeric(unique(stringr::str_sub(raw.mls, start = 7, end = 7)))
locs=as.character(na.exclude(unique(stringr::str_extract(string = colnames(data), pattern = "\\d{3}\\.\\d{3}"))))
sp.locs=unique(substr(x=locs, start = 3,3))
sp.locs=sp.locs[!sp.locs==0]
ml.locs=unique(substr(x=locs, start=6,6))
ml.locs=ml.locs[!ml.locs==0]
all.locs=list(ml.locs=ml.locs, sp.locs=sp.locs)
## Below function from answer provided by Joris Meys, on stackoverflow.com.
## Retrieved Dec 20, 2017 from https://stackoverflow.com/questions/7077710/sequence-length-encoding-using-r?rq=1
seq.length <- function(x){
if(!is.numeric(x)) x <- as.numeric(x)
n <- length(x)
y <- x[-1L] != x[-n] + 1L
i <- c(which(y|is.na(y)),n)
data.frame(
start_index = as.vector(x[head(c(0L,i)+1L,-1L)]),
stop_index = as.vector(diff(c(0L,i)))
)
}
soil.DPs=c("DP1.00040.001", "DP1.00041.001", "DP1.00095.001")
data.time.table=function(l, loc){
l=as.character(l)
if(loc=="sp"){
l.data=Noble::sp.extract(data=data, sp = l)
}else if(loc=="ml"){
l.data=Noble::ml.extract(data=data, ml = l)
}
gaps=Noble::find.gap(data = l.data, time.agr = 30, return = "index")
no.data.times=seq.length(gaps$no.data.indx)
no.data.times$stop_index=(no.data.times$start_index+no.data.times$stop_index-1)
location=paste0(toupper(loc),"-", l)
no.data.times=data.frame(location=rep(location, times=nrow(no.data.times)),gap.start=l.data$startDateTime[no.data.times$start_index], gap.end=l.data$startDateTime[no.data.times$stop_index])
}
qf.time.table=function(l, loc){
if(loc=="sp"){
l.data=Noble::sp.extract(data=data, sp = l)
}else if(loc=="ml"){
l.data=Noble::ml.extract(data=data, ml = l)
}
gaps=Noble::find.gap(data = l.data, time.agr = 30, return = "index")
no.qf.times=seq.length(gaps$no.qf.indx)
no.qf.times$stop_index=(no.qf.times$start_index+no.qf.times$stop_index-1)
location=paste0(toupper(loc),"-", l)
no.qf.times=data.frame(location=rep(location, times=nrow(no.qf.times)),gap.start=l.data$startDateTime[no.qf.times$start_index], gap.end=l.data$startDateTime[no.qf.times$stop_index])
}
sp.no.data=lapply(all.locs$sp.locs, function(l) data.time.table(l, loc="sp"))
sp.no.qf=lapply(all.locs$sp.locs, function(l) qf.time.table(l, loc="sp"))
ml.no.data=lapply(all.locs$ml.locs, function(l) data.time.table(l, loc="ml"))
ml.no.qf=lapply(all.locs$ml.locs, function(l) qf.time.table(l, loc="ml"))
ml.no.data
no.data.times=rbind(do.call(rbind, sp.no.data), do.call(rbind, ml.no.data))
no.qf.times=rbind(do.call(rbind, sp.no.qf), do.call(rbind, ml.no.qf))
no.qf.times
no.data.times=no.data.times[-which(no.data.times[,2]==no.data.times[,3]),] #weed out weird duplicates
no.data.times
no.data.times=rbind(do.call(rbind, sp.no.data), do.call(rbind, ml.no.data))
no.data.times=no.data.times[!(which(no.data.times[,2]==no.data.times[,3]),] #weed out weird duplicates
no.data.times=no.data.times[!(which(no.data.times[,2]==no.data.times[,3])),] #weed out weird duplicates
View(no.data.times)
no.data.times=rbind(do.call(rbind, sp.no.data), do.call(rbind, ml.no.data))
no.data.times[,2]==no.data.times[,3]
!(no.data.times[,2]==no.data.times[,3])
no.data.times=no.data.times[!(no.data.times[,2]==no.data.times[,3]),] #weed out weird duplicates
library(Noble)
time.agr = 30
files=Noble::pull.eddy.data(site, bgn.month, end.month, package="basic", save.dir)
site="CPER"
files=Noble::pull.eddy.data(site, bgn.month, end.month, package="basic", save.dir)
save.dir="~/Desktop/"
files=Noble::pull.eddy.data(site, bgn.month, end.month, package="basic", save.dir)
bgn.month="2017-08"
end.month="2017-09"
files=Noble::pull.eddy.data(site, bgn.month, end.month, package="basic", save.dir)
file.dir=Noble:::.data.route(site = site, save.dir = save.dir)
soni.raw=lapply(files, function(x) Noble::hdf5.to.df(site, hdf5.file=paste0(file.dir,x), meas.name="soni", time.agr, save.dir))
soni.df=do.call(rbind, soni.raw)
soni.df$timeBgn=gsub(x = soni.df$timeBgn, pattern = "T", replacement = " ")
soni.df$timeBgn=gsub(x = soni.df$timeBgn, pattern = "z", replacement = "")
soni.df$timeBgn=as.POSIXct(soni.df$timeBgn, tz="UTC")
soni.df$timeBgn=format(soni.df$timeBgn, tz="UTC")
ref.times=data.frame(timeBgn=Noble::help.time.seq(from = as.Date(paste0(bgn.month, "-01")), to=Noble::end.day.time(end.month = end.month, time.agr = time.agr), time.agr = time.agr))
ref.times$timeBgn=format(as.POSIXct(ref.times$timeBgn, tz = "UTC"), tz="UTC")
test.data=merge(x=ref.times, y=soni.df, by="timeBgn", all.x = T)
if(length(test.data)>1){
data.indx<-grep(x=colnames(test.data), pattern="mean.velo*axsErth") #pattern="mean.veloZaxsErth"
qf.indx<-grep(x=colnames(test.data), pattern="qfFinl.angZaxsErth")
#qf.indx<-append(qf.indx, grep(x=colnames(test.data), pattern="^finalQF*"))
bgn.day=as.Date(paste0(bgn.month, "-01"))
end.day=as.POSIXct(Noble::end.day.time(end.month = end.month, time.agr = 1440))
days=round(difftime(end.day, bgn.day, units="days"), digits = 2)
end.day=lubridate::round_date(end.day, "day")
all.data=length(data.indx)*length(test.data[,1])
num.nas<-sum(is.na(test.data[,data.indx]))
num.data<-sum(!is.na(test.data[,data.indx]))
data.quant<-round(100*(num.data/(all.data)), digits = 2)
num.qf.fail<-sum(test.data[,qf.indx]==1, na.rm=TRUE)
num.qf.pass<-sum(test.data[,qf.indx]==0, na.rm = TRUE)
num.qf.na<-sum(is.na(test.data[,qf.indx]))
data.valid<-round(100*(num.qf.pass/(all.data)), digits = 2)
##### WRITE RESULTS
dq.rslt<-data.frame(site=site,
time_performed=as.character(Sys.time()),
begin_month=bgn.month,
end_month=end.month,
days_tested=days,
data_product="DP4.00200.001",
variable_tested="mean.veloZaxsErth",
data_quantity=data.quant,
data_validity=data.valid,
quant_threshold= q.th,
valid_threshold=v.th
)
if(file.exists(Noble:::.result.route(save.dir))){
dq.rpt <- data.frame(read.csv(file = Noble:::.result.route(save.dir), header = T, stringsAsFactors = T))
dq.rpt <- rbind(dq.rpt, dq.rslt)
write.csv(x = dq.rpt, file = Noble:::.result.route(save.dir), row.names = F)
}else{
write.csv(x = dq.rslt, file = Noble:::.result.route(save.dir), col.names = T, row.names = F)
}
}
data.indx<-grep(x=colnames(test.data), pattern="mean.velo*axsErth") #pattern="mean.veloZaxsErth"
qf.indx<-grep(x=colnames(test.data), pattern="qfFinl.angZaxsErth")
bgn.day=as.Date(paste0(bgn.month, "-01"))
data.indx
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\\*axsErth") #pattern="mean.veloZaxsErth"
data.indx
?grep
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\*axsErth") #pattern="mean.veloZaxsErth"
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\*axsErth") #pattern="mean.veloZaxsErth"
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\\*axsErth") #pattern="mean.veloZaxsErth"
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\\.axsErth") #pattern="mean.veloZaxsErth"
data.indx
data.indx<-grep(x=colnames(test.data), pattern="mean.velo") #pattern="mean.veloZaxsErth"
data.indx
colnames(test.data)[data.indx]
data.indx<-grep(x=colnames(test.data), pattern="mean.velo[:upper:]axsErth") #pattern="mean.veloZaxsErth"
colnames(test.data)[data.indx]
data.indx
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\\[:upper:]axsErth") #pattern="mean.veloZaxsErth"
grep(x=colnames(test.data), pattern="qfFinl.angZaxsErth")
grep(x=colnames(test.data), pattern="mean.velo\\[:upper:]axsErth")
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\\[:upper:]") #pattern="mean.veloZaxsErth"
data.indx
data.indx<-grep(x=colnames(test.data), pattern="mean.velo[:upper:]") #pattern="mean.veloZaxsErth"
data.indx
data.indx<-grep(x=colnames(test.data), pattern="mean.velo\\.") #pattern="mean.veloZaxsErth"
data.indx
data.indx<-grep(x=colnames(test.data), pattern="mean.velo.") #pattern="mean.veloZaxsErth"
data.indx
data.indx<-grep(x=colnames(test.data), pattern="mean\\.velo.axsErth") #pattern="mean.veloZaxsErth"
data.indx
qf.indx<-grep(x=colnames(test.data), pattern="qfFinl.angZaxsErth")
bgn.day=as.Date(paste0(bgn.month, "-01"))
end.day=as.POSIXct(Noble::end.day.time(end.month = end.month, time.agr = 1440))
days=round(difftime(end.day, bgn.day, units="days"), digits = 2)
end.day=lubridate::round_date(end.day, "day")
all.data=length(data.indx)*length(test.data[,1])
num.nas<-sum(is.na(test.data[,data.indx]))
num.data<-sum(!is.na(test.data[,data.indx]))
data.quant<-round(100*(num.data/(all.data)), digits = 2)
num.qf.fail<-sum(test.data[,qf.indx]==1, na.rm=TRUE)
num.qf.pass<-sum(test.data[,qf.indx]==0, na.rm = TRUE)
num.qf.na<-sum(is.na(test.data[,qf.indx]))
data.valid<-round(100*(num.qf.pass/(all.data)), digits = 2)
data.valid
library(Noble)
# EDIT
test <- "TIS 3D Wind Speed and Direction Process Quality "
testSubDir <- "Tis3DWindSpeedProcessQuality"
if(grepl("darwin", version$os))
{
dirCommBase<-"/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/"
}else{
dirCommBase<-"N:/Science/Science Commissioning Archive/SiteAndPayload/"
}
# should not need to edit these...
myTitle <- paste("TIS Commissioning Test Report:", test, "Assessment")
rmdFile <- paste( testSubDir, ".Rmd", sep="")
testFullDir <- paste(dirCommBase, testSubDir, sep="")
### General Params
bgn.month = "2017-09"
end.month = "2017-10"
test.sites="DEJU"
#test.sites=c("OSBS", "KONZ", "CPER", "SRER", "UNDE", "CLBJ", "JERC", "BART")
if(file.exists(paste0(testFullDir,"/Common/summary_results.csv"))){
summary_results=read.csv(paste0(testFullDir, "/Common/summary_results.csv"))
passed.sites=summary_results$site[as.logical(summary_results$passed)]
}else{passed.sites=c()}
## NO TESTS ##
#test.sites=c("JERC")
for(i in 1:length(test.sites)){
sink<-try(
Noble::soni.pq.test(site=test.sites[i], bgn.month=bgn.month, end.month=end.month, save.dir=testFullDir, v.th = 80)
)
}
parsed.results=Noble::parse.results(test.dir = testFullDir, write.summary = T)
NEON.avail()
NEON.avail("DP4.00200.001")
# EDIT
test <- "TIS 3D Wind Speed and Direction Process Quality "
testSubDir <- "Tis3DWindSpeedProcessQuality"
if(grepl("darwin", version$os))
{
dirCommBase<-"/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/"
}else{
dirCommBase<-"N:/Science/Science Commissioning Archive/SiteAndPayload/"
}
# should not need to edit these...
myTitle <- paste("TIS Commissioning Test Report:", test, "Assessment")
rmdFile <- paste( testSubDir, ".Rmd", sep="")
testFullDir <- paste(dirCommBase, testSubDir, sep="")
### General Params
bgn.month = "2017-09"
end.month = "2017-10"
test.sites=
test.sites=c("OSBS", "KONZ", "CPER", "SRER", "UNDE", "CLBJ", "JERC", "BART", "DEJU")
if(file.exists(paste0(testFullDir,"/Common/summary_results.csv"))){
summary_results=read.csv(paste0(testFullDir, "/Common/summary_results.csv"))
passed.sites=summary_results$site[as.logical(summary_results$passed)]
}else{passed.sites=c()}
## NO TESTS ##
#test.sites=c("JERC")
for(i in 1:length(test.sites)){
sink<-try(
Noble::soni.pq.test(site=test.sites[i], bgn.month=bgn.month, end.month=end.month, save.dir=testFullDir, v.th = 80)
)
}
sink<-try(
Noble::soni.pq.test(site="LAJA", bgn.month="2017-08", end.month="2017-09", save.dir=testFullDir, v.th = 80))
parsed.results=Noble::parse.results(test.dir = testFullDir, write.summary = T)
read.csv(file = "/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/Tis3DWindSpeedProcessQuality/D10-CPER/CPER_2017-10_DP4.00200.001.zip")
read.csv(file = "/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/Tis3DWindSpeedProcessQuality/D10-CPER/soni_CPER_2017-09-01-2017-09-30.csv")
soni-data=read.csv(file = "/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/Tis3DWindSpeedProcessQuality/D10-CPER/soni_CPER_2017-09-01-2017-09-30.csv")
soni.data=read.csv(file = "/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/Tis3DWindSpeedProcessQuality/D10-CPER/soni_CPER_2017-09-01-2017-09-30.csv")
plot.data=data.frame(time=soni.data$timeBgn, numPts=soni.data$numSamp.veloZaxsErth, qf=soni.data$qfFinl.angZaxsErth)
soni.data=read.csv(file = "/Volumes/neon/Science/Science Commissioning Archive/SiteAndPayload/Tis3DWindSpeedProcessQuality/D10-CPER/soni_CPER_2017-09-01-2017-09-30.csv")
plot.data=data.frame(time=soni.data$timeBgn, numPts=soni.data$numSamp.veloZaxsErth, qf=soni.data$qfFinl.angZaxsErth)
plot.data=data.frame(time=soni.data$timeBgn, numPts=soni.data$numSamp.veloZaxsErth, qf=soni.data$qfFinl.angZaxsErth)
m.plot=melt(data=plot.data, id.vars=time)
m.plot=melt(data=plot.data, id.vars=time)
m.plot
m.plot=melt(data=plot.data, id.vars=time)
m.plot=melt(data=plot.data, id.vars="time")
m.plot
m.plot$time=as.POSIXct(gsub(m.plot$time, pattern = "T|Z", replacement = ""), format=)
m.plot$time
m.plot$time=as.POSIXct(gsub(m.plot$time, pattern = "T|Z", replacement = ""), tz="UTC")
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(variable)))+geom_point()
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(variable)))+geom_point(aes(color=group))
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(variable), color=as.factor(variable)))+geom_point(aes(color=group))
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(variable), color=as.factor(variable)))+geom_point()
m.plot=melt(data=plot.data, id.vars=c("time", "qf"))
m.plot$time=as.POSIXct(gsub(m.plot$time, pattern = "T|Z", replacement = ""), tz="UTC")
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(variable), color=as.factor(variable)))+geom_point()
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(qf), color=as.factor(variable)))+geom_point()
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(qf), color=as.factor(qf)))+geom_point()
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(qf), color=as.factor(qf)))+geom_point()+scale_fill_manual(values=("blue", "purple"))
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(qf), color=as.factor(qf)))+geom_point()+scale_fill_manual(values=c("blue", "purple"))
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(qf), color=as.factor(qf)))+geom_point()+ggplot2::scale_color_manual(values = niceColors, name = "Final Quality Flag", limits=c(0, 1, "NA"))+ggplot2::theme_bw() +
ggplot2::labs(x="Date/Time", y=nameData, title="Number of 3D sonic anemometer data points")
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(qf), color=as.factor(qf)))+geom_point()+ggplot2::scale_color_manual(values = niceColors, name = "Final Quality Flag", limits=c(0, 1, "NA"))+ggplot2::theme_bw() +
ggplot2::labs(x="Date/Time", y="Number of Measurements", title="Number of 3D sonic anemometer data points")
niceColors<- c("0"="#41f299", "1"="#f25841", "NA"="black")
ggplot(data=m.plot, aes(x=time, y=value, group=as.factor(qf), color=as.factor(qf)))+geom_point()+ggplot2::scale_color_manual(values = niceColors, name = "Final Quality Flag", limits=c(0, 1, "NA"))+ggplot2::theme_bw() +
ggplot2::labs(x="Date/Time", y="Number of Measurements", title="Number of 3D sonic anemometer data points")
test <- "Soil Heat Flux Process Quality"
testSubDir <- "TisSoilHeatFluxProcessQuality"
if(grepl("darwin", version$os))
{
mountPoint<-"/Volumes/neon/" #Mac
}else{
mountPoint<-"N:/" #Windows
}
dirCommBase = paste0(mountPoint, "Science/Science Commissioning Archive/SiteAndPayload/")
test <- "Soil Heat Flux Process Quality"
testSubDir <- "TisSoilHeatFluxProcessQuality"
if(grepl("darwin", version$os))
{
mountPoint<-"/Volumes/neon/" #Mac
}else{
mountPoint<-"N:/" #Windows
}
dirCommBase = paste0(mountPoint, "Science/Science Commissioning Archive/SiteAndPayload/")
test <- "Soil Heat Flux Process Quality"
testSubDir <- "TisSoilHeatFluxProcessQuality"
if(grepl("darwin", version$os))
{
mountPoint<-"/Volumes/neon/" #Mac
}else{
mountPoint<-"N:/" #Windows
}
dirCommBase = paste0(mountPoint, "Science/Science Commissioning Archive/SiteAndPayload/")
# should not need to edit these...
myTitle <- paste("TIS Commissioning Test Report:", test, "Assessment")
rmdFile <- paste( testSubDir, ".Rmd", sep="")
testFullDir <- paste0(dirCommBase, testSubDir,"/")
dir = testFullDir
double_dot=list.files(path=dir, recursive = T, full.names = T, pattern = "\\.\\.")
double_dot
file.remove(double_dot)
double_dot=list.files(path=dir, recursive = T, full.names = T, pattern = "\\.\\.")
double_dot
double_dot=list.files(path=dir, recursive = T, full.names = T, pattern = "00001")
double_dot
file.remove(double_dot)
double_dot=list.files(path=dir, recursive = T, full.names = T, pattern = "DS_Store")
file.remove(double_dot)
double_dot=list.files(path=dir, recursive = T, full.names = T, pattern = "DS_Store", all.files = T)
file.remove(double_dot)
double_dot=list.files(path=dir, recursive = T, full.names = T, pattern = "00040", all.files = T)
double_dot
double_dot=list.files(path=dir, recursive = T, full.names = T, pattern = ".csv$", all.files = T)
double_dot
file.remove(double_dot[3])
ERlist <- as.data.frame(rbind(
"name1" = c("name"="https://github.com/NEONScience/Noble - Github repository for the Noble software package used in this test to automate accessing data from the NEON data portal.")
# any additional documents...
))
ERlist <- cbind(ERlist,
"ref"= paste("ER[",
formatC(1:nrow(ERlist), width=2, flag="0"),
"]",
sep="")
)
ERref["name1"]
ERList
ERlist
ERlist$ref["name1"]
ERlist$ref[name1]
class(ERlist)
ERlist$ref
# Documents will be assigned an ER[##] in the order they are listed
# To reference these documents in text, use this: `r ERref("key")` where key is e.g. "name1"
options(stringsAsFactors = F)
ERlist <- as.data.frame(rbind(
"name1" = c("name"="https://github.com/NEONScience/Noble - Github repository for the Noble software package used in this test to automate accessing data from the NEON data portal.")
# any additional documents...
))
ERlist <- cbind(ERlist,
"ref"= paste("ER[",
formatC(1:nrow(ERlist), width=2, flag="0"),
"]",
sep="")
)
ERlist
ERlist$ref
rownames(ERlist)
ERlist$ref["name1"]
ERlist$ref[1]
akima::bilinear.grid(x=seq(151), y=seq(151), rmat, nx = 151, ny = 151)
akima::bilinear.grid(x=seq(151), y=seq(151), flux, nx = 151, ny = 151)
